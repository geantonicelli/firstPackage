#' function to automatically retrieve sequences from a databank based on
#'   accession numbers
#'
#' this is a function to retrieve sequences of DNA, RNA or protein from
#'   databases structured under ACNUC and located on the web, the retrieval is
#'   limited to accession numbers as selection criteria, remote access to ACNUC
#'   databases works by opening a socket connection on a port (for example on port
#'   number 5558 at pbil.univ-lyon1.fr) and by communicating on this socket
#'   following the protocol described
#' \href{http://doua.prabi.fr/databases/acnuc/remote_acnuc.html}{here}
#'
#'
#' @param seqnames a character vector specifying the accession numbers of the
#'   sequences to be retrieved
#' @param acnucdb a character string specifying the name of the ACNUC database
#'   to be searched. Use \code{\link[seqinr]{choosebank}} without arguments to
#'   see a list of available databases
#'
#' @return this function returns a named list with the sequences matching the
#'   sequence names of class SeqAcnucWeb retrieved by
#'   \code{\link[seqinr]{query}} based on the provided accession numbers the
#'   name of each list item is composed of the accession number and the length
#'   of the sequence
#'
#' @examples
#' seqs <- retrieve_seqs(c('P06747', 'P0C569', 'O56773', 'Q5VKP1'), 'swissprot')
#' \dontrun{viruses_annot <- read.csv(system.file('extdata', 'CoV_genomes_annot.csv', package='firstPackage'))}
#' \dontrun{accessions <- viruses_annot$accession}
#' \dontrun{seqs <- retrieve_seqs(accessions, 'genbank')}
#' \dontrun{str(seqs)}
#'
#' @importFrom seqinr choosebank query getSequence
#'
#' @export
retrieve_seqs <- function(seqnames, acnucdb){
                          myseqs <- list()
                          choosebank(acnucdb)
                          for(i in 1:length(seqnames)){
                              seqname <- seqnames[i]
                              print(paste('retrieving sequence', seqname, '...'))
                              query <- paste('AC=', seqname, sep='')
                              query2 <- query('query2', `query`)
                              seq <- getSequence(query2$req[[1]])
                              myseqs[[i]] <- seq
                              name <- paste(seqname, 'length', length(seq), sep=' ')
                              names(myseqs)[[i]] <- name
                              }
                          closebank()
                          return(myseqs)
                          }

#' function to print an ordered sequences alignment in chunks of defined size
#'
#' this is a function that takes an alignment in phylip format made by an
#'   alignment software like clustal omega and print it to the console in an
#'   ordered display of defined sequence width the function calculates the number
#'   of letters printed so far and print this number together with the name of
#'   each sequence at the end of each chunk
#'
#' @param alignment object of type alignment of the package seqinr with the
#'   aligned sequences to be display. A file in format phylip is generated by an
#'   alignment software from a .fasta file containing the sequences and loaded
#'   to the R environment
#' @param chunksize integer specifying the number of sequence letters to be
#'   printed in each chunk of display
#'
#' @return this function print the sequence alignment to the console in an
#'   ordered fashion
#'
#' @examples
#' virusaln <- read.alignment(file=system.file('extdata', 'phosphoproteins.phy', package='firstPackage'), format='phylip')
#' print_alignment(virusaln, 80)
#'
#' @importFrom seqinr read.alignment
#' @importFrom Biostrings countPattern
#'
#' @export
print_alignment <- function(alignment, chunksize=60){
                            numseqs <- alignment$nb
                            alignmentlen <- nchar(alignment$seq[[1]])
                            starts <- seq(1, alignmentlen, by=chunksize)
                            n <- length(starts)
                            aln <- vector()
                            lettersprinted <- vector()
                            for(j in 1:numseqs){
                                aln[j] <- alignment$seq[[j]]
                                lettersprinted[j] <- 0
                                }
                            for(i in 1:n){
                                for(j in 1:numseqs){
                                    alnj <- aln[j]
                                    chunkseqjaln <- substring(alnj, starts[i], starts[i]+chunksize-1)
                                    chunkseqjaln <- toupper(chunkseqjaln)
                                    gapsj <- countPattern('-', chunkseqjaln)
                                    lettersprinted[j] <- lettersprinted[j]+chunksize-gapsj
                                    print(paste(chunkseqjaln, lettersprinted[j], alignment$nam[j]), quote=FALSE)
                                    }
                                print(paste(''), quote=FALSE)
                                }
                            }

#' function to discard very poorly conserved regions from a sequences alignment
#'   before building a phylogenetic tree
#'
#' very poorly conserved regions are likely to be regions that are either not
#'   homologous between the sequences being considered (and so do not add any
#'   phylogenetic signal), or are homologous but are so diverged that they are
#'   very difficult to align accurately (and so may add noise to the phylogenetic
#'   analysis, and decrease the accuracy of the inferred tree) this function takes
#'   an alignment in phylip format made by an alignment software like clustal
#'   omega and clean the alignment based on a defined percentage of non-gap
#'   positions and a defined percentage of sequence identity between all sequences
#'   considered for phylogenetic analysis
#'
#' @param alignment object of type alignment in phylip format with the aligned
#'   sequences to be checked for similarity and cleaned. A file in format phylip
#'   is generated by an alignment software from a .fasta file containing the
#'   sequences and loaded to the R environment
#' @param minpcnongap integer for the desired minimal percentage of non-gap
#'   positions between alignments for each position being analysed
#' @param minpcid integer for the desired minimal percentage of sequence
#'   identity between alignments for each position being analysed
#'
#' @return this function returns a sequences alignment in phylip format
#'
#' @examples
#' virusaln <- read.alignment(file=system.file('extdata', 'phosphoproteins.phy', package='firstPackage'), format='phylip')
#' cleanedvirusaln <- clean_alignment(virusaln, 30, 30)
#' print_alignment(cleanedvirusaln)
#'
#' @export
clean_alignment <- function(alignment, minpcnongap, minpcid){
                            newalignment <- alignment
                            numseqs <- alignment$nb
                            alignmentlen <- nchar(alignment$seq[[1]])
                            for(j in 1:numseqs){
                                newalignment$seq[[j]] <- ''
                                }
                            for(i in 1:alignmentlen){
                                nongap <- 0
                                for(j in 1:numseqs){
                                    seqj <- alignment$seq[[j]]
                                    letterij <- substr(seqj, i, i)
                                    if(letterij != '-'){
                                       nongap <- nongap + 1
                                       }
                                    }
                                pcnongap <- (nongap*100)/numseqs
                                if(pcnongap >= minpcnongap){
                                   numpairs <- 0
                                   numid <- 0
                                   for(j in 1:(numseqs-1)){
                                       seqj <- alignment$seq[[j]]
                                       letterij <- substr(seqj, i, i)
                                       for(k in (j+1):numseqs){
                                           seqk <- alignment$seq[[k]]
                                           letterkj <- substr(seqk, i, i)
                                           if(letterij != '-' && letterkj != '-'){
                                              numpairs <- numpairs + 1
                                              if(letterij==letterkj){
                                                 numid <- numid + 1
                                                 }
                                              }
                                           }
                                       }
                                   pcid <- (numid*100)/(numpairs)
                                   if(pcid >= minpcid){
                                      for(j in 1:numseqs){
                                          seqj <- alignment$seq[[j]]
                                          letterij <- substr(seqj, i, i)
                                          newalignmentj <- newalignment$seq[[j]]
                                          newalignmentj <- paste(newalignmentj, letterij, sep='')
                                          newalignment$seq[[j]] <- newalignmentj
                                          }
                                     }
                                   }
                                }
                            return(newalignment)
                            }

#' function to load a file containing a sequences alignment generated by an
#'   alignment software
#'
#' this function is wrapper around the functions
#'   \code{\link{[seqinr]{read.alignment}}},
#'   \code{\link{[adegenet]{fasta2DNAbin}}} and \code{\link{[ape]{as.DNAbin}}}.
#'   The goal of this function is to load different types of sequences alignments,
#'   i.e. protein, DNA, RNA, in different formats, i.e. fasta, phylip, mase,
#'   clustal or msf and to convert it in the best suitable object class for
#'   generating a distance matrix either with the seqnir or the ape package
#'
#' @param file a character string specifying the path to the file containing a
#'   sequences alignment to be loaded to the global environment
#' @param format a character string specifying the format of the file, i.e.
#'   fasta, phylip, mase, clustal or msf (no default)
#' @param type a character string specifying type of sequences, i.e. protein,
#'   DNA, RNA (default: protein)
#'
#' @return if the input type is DNA or RNA this function returns an object of
#'   class DNAbin, if the input type is protein or unspecified (default) this
#'   function returns an object of class alignment of the package seqinr
#'
#' @examples
#' fastaRNA_load <- load_alignment(system.file('extdata', 'spike_align.fasta', package='firstPackage'), 'fasta', 'RNA')
#' phylipRNA_load  <- load_alignment(system.file('extdata', 'spike_align.phy', package='firstPackage'), 'phylip', 'RNA')
#' phylipProt_load <- load_alignment(system.file('extdata', 'spike_prot_align.phy', package='firstPackage'), 'phylip', 'protein')
#' # loading a RNA sequences alignment as an object of class alignment for the seqinr package and not the default class DNAbin for the ape package
#' clustalRNA_load <- load_alignment(system.file('extdata', 'spike_align.aln', package='firstPackage'), 'clustal')
#' msfRNA_load <- load_alignment(system.file('extdata', 'orf1ab_align.msf', package='firstPackage'), 'msf', 'RNA')
#' maseProtein_load <- load_alignment(system.file('extdata', 'prot.mase', package='firstPackage'), 'mase')
#'
#' # data(fastaRNA); stopifnot(identical(fastaRNA, fastaRNA_load))
#' # data(phylipRNA); stopifnot(identical(phylipRNA, phylipRNA_load))
#' # data(phylipProt); stopifnot(identical(phylipProt, phylipProt_load))
#' # data(clustalRNA); stopifnot(identical(clustalRNA, clustalRNA_load))
#' # data(msfRNA); stopifnot(identical(msfRNA, msfRNA_load))
#' # data(maseProtein); stopifnot(identical(maseProtein, maseProtein_load))
#'
#' @importFrom seqinr read.alignment
#' @importFrom adegenet fasta2DNAbin
#' @importFrom ape as.DNAbin
#'
#' @export
load_alignment <- function(file, format, type='protein'){
                           if(type=='protein'){
                              alignment <- read.alignment(file, format)
                              }
                           else if(type=='DNA' || type=='RNA'){
                                   if(format=='fasta' || format=='fa'){
                                      alignment <- fasta2DNAbin(file)
                                      }

                                   else{align <- read.alignment(file, format)
                                        alignment <- as.DNAbin(align)
                                        }
                                   }
                           return(alignment)
                           }
